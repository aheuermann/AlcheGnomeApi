// Generated by CoffeeScript 1.6.3
(function() {
  var AlchemyAPI, T, Twit, alchemy, app, async, express, getSentiment, getTweets, port, _, _ref;

  Twit = require('twit');

  AlchemyAPI = require('alchemy-api');

  async = require('async');

  _ = require('underscore');

  express = require('express');

  app = express();

  app.all('*', function(req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "X-Requested-With");
    return next();
  });

  T = new Twit({
    consumer_key: 'Z2lf3HcjTwaOFmynyt5cgQ',
    consumer_secret: 'FRCfnAScX3Yg6YmcQmHKeoXJTRxZV82v69scKf4jCHQ',
    access_token: '11726242-WOb8IRAMFmrO3hU6xPrk9I0n3iwG408VDWNXshAHa',
    access_token_secret: 'GXIkzXP5GMi4XNfBlJCOq9W5e1YPyFfOkHybRFQOSY4'
  });

  alchemy = new AlchemyAPI('48d4b10b0009b09a9480bf64609620ff69c42dac');

  getSentiment = function(tweet, done) {
    if (tweet != null ? tweet.text : void 0) {
      return alchemy.sentiment(tweet.text, {}, function(err, response) {
        tweet.sentiment = response.docSentiment;
        return done();
      });
    } else {
      return done();
    }
  };

  getTweets = function(q, callback) {
    var all, count, sinceId;
    all = [];
    sinceId = null;
    count = 10;
    q.count = 100;
    return async.whilst(function() {
      return count > 0;
    }, function(done) {
      console.log("Iteration " + count);
      count--;
      if (sinceId) {
        q.sinceId = sinceId;
      }
      return T.get('statuses/user_timeline', q, function(err, tweets) {
        all = all.concat(tweets);
        return done(err);
      });
    }, function(err) {
      console.log("Grabbed: " + all.length);
      console.log(all[0]);
      return callback(err, _.map(all, function(t) {
        return _.pick(t, ['text', 'sentiment']);
      }));
    });
  };

  app.get('/api/:user', function(req, res) {
    var q;
    q = {
      screen_name: req.params.user
    };
    return async.waterfall([
      function(next) {
        return getTweets(q, next);
      }, function(tweets, next) {
        if (tweets && (tweets != null ? tweets.length : void 0) > 0) {
          return async.eachLimit(tweets, 1, getSentiment, function(err) {
            return done(null);
          });
        } else {
          return done(null, []);
        }
      }
    ], function(err, results) {
      if (results) {
        return res.send(results);
      } else {
        return res.send("No tweets for \"" + req.params.user + "\"");
      }
    });
  });

  port = (typeof process !== "undefined" && process !== null ? (_ref = process.env) != null ? _ref.PORT : void 0 : void 0) || 3000;

  app.listen(port);

  console.log("listening " + port);

}).call(this);
